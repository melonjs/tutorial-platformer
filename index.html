<!DOCTYPE HTML>
<head>
    <title>melonJS</title>
    <meta name="description" content="melonJS Tutorial"/>
    <meta name="keywords" content=
    "melonJS, lightweight, HTML5 game engine, HTML5, javascript, canvas, game, engine, framework, tiled, tile, map, loader, parser, TMX, XML, tutorial"/>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" type="text/css" href="style/style.css" title="style"/>
    <script type="text/javascript">
        //<![CDATA[

        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-13050059-3']);
        _gaq.push(['_trackPageview']);

        (function() {
            var ga = document.createElement('script');
            ga.type = 'text/javascript';
            ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(ga, s);
        })();

        //]]>
        </script>
        <script type="text/javascript" src="SyntaxHighlighter/shCore.js"></script>
        <script type="text/javascript" src="SyntaxHighlighter/shBrushJScript.js"></script>
        <link href="SyntaxHighlighter/shCore.css" rel="stylesheet" type="text/css" />
        <link href="SyntaxHighlighter/shThemeDefault.css" rel="stylesheet" type="text/css" />
        <style type="text/css">
        /*<![CDATA[*/
        pre.c2 {
            font-family: Andale Mono, Lucida Console, Monaco, fixed, monospace;
            color: #000000;
            background-color: #eee;
            font-size: 12px;
            border: 1px dashed #999999;
            line-height: 14px;
            padding: 5px;
            overflow: auto;
            width: 100%
        }

        p.c1 {
            font-weight: bold;
            padding: 0;
        }

        /*]]>*/
        </style>
    </head>

    <body>
        <div id="main">
            <div id="header">
                <div id="logo">
                    <div id="logo_text">
                        <!-- class="logo_colour", allows you to change the colour of the text -->
                        <h1><a href="http://www.melonjs.org">melon<span class="logo_colour">JS</span></a></h1>
                        <h2>A lightweight HTML5 game engine</h2>
                    </div>
                </div>
            </div>

            <div id="site_content">
                <a href="https://github.com/melonjs/melonjs"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_white_ffffff.png" alt="Fork me on GitHub"></a>
                <div class="sidebar">
                    <p><img src="media/HTML5_Badge_128.png" alt="HTML5 badge"/></p>

                    <h3>Useful Links</h3>

                    <ul>
                        <li><a href="http://www.melonjs.org/">melonJS Homepage</a></li>
                        <li><a href="http://www.mapeditor.org/">Tiled Homepage</a></li>
                        <li><a href="http://melonjs.github.io/docs/">melonJS online documentation</a></li>
                    </ul>
                </div>
                <div id="content">
                    <!-- insert the page content here -->
                    <h1>A platformer step by step creation tutorial</h1>

                    <h2>Introduction:</h2>

                    <p class="c1">Prerequisites :</p>

                    <ul>
                        <li>The <a href="http://www.mapeditor.org/">Tiled Map Editor</a>, installed
                            and running (0.9.0 or later)
                        </li>
                        
                        
                        <li>
                            The melonJS <a href="https://github.com/melonjs/boilerplate/archive/master.zip">boilerplate</a>, 
                            that we will use as default template project for our tutorial. 
                        </li>
                        <li>
                            The tutorial <a href="tutorial_data.zip">data files</a>, to be uncompressed into the (here above) template data directory, 
                            and which contains the following :</li>
                            <ul>
                                <li>a level tileset and a metatileset for collision </li>
                                <li>two backgrounds for parallax layers</li>
                                <li>some basic spritesheets </li>
                                <li>some audio sfx and music</li>
                                <li>a title screen background</li>
                            </ul>

                            <li>The melonJS <a href="http://www.melonjs.org/download.html"> library</a>, 
                                to be copied under the /lib directory (be sure to download both the minified and plain version, as the latter might potentially be required for debugging purpose)
                            </li>

                            <li>The melonJS <a href="http://www.melonjs.org/docs/index.html">documentation</a>
                                for more details
                            </li>
                        </ul>

                        <p><b>Testing/debugging :</b><br/>
                            When using Chrome, and due to the "cross-origin request" security mechanism implemented, 
                            you need to use the "--disable-web-security" parameter or better "--allow-file-access-from-files" 
                            when launching the browser in order to test any local content, else the browser will complain 
                            when trying to load a level map. <br/></p>

                            <p class="c1">Additional Credits :</p>

                            <ul>
                                <li><a href="http://www.spicypixel.net/2008/01/10/gfxlib-fuzed-a-free-developer-graphic-library/">
                                    SpicyPixel.NET</a> for the GfxLib-Fuzed assets</li>
                                    <li><a href="http://www.nosoapradio.us/">noSoapRadio</a> for the in game music</li>
                                </ul>

                                <p>Feel free to modify whatever you want. We also assume here, that you are already
                                    familiar with Tiled; if you need more help with the tool, you can check the Tiled
                                    homepage and <a href="https://github.com/bjorn/tiled/wiki">wiki</a> for further help.</p>

                                    <h2><a id="part1">Part 1: Creating a level using Tiled</a></h2>


                                    <p>First let's open Tiled and create a new map : for this tutorial we will we use a
                                        640x480 canvas, and since we have 32x32 tiles, we must specify at least 20 and 15 for
                                        the map size. In my example I'll define a <b>40x15</b> level, so we can play with
                                        scrolling background later.</p>
                                    <img src="media/step1_newmap.png" alt= "Step 1 of creating a new map"/>

                                    <p>Also, as melonJS supports only <i><b>uncompressed</b></i> tilemaps, please be sure that 
                                     your settings are correct. We do recommend the Base64 encoding, since it produces a smaller file, 
                                     but it's really up to you.<br>
                                        

                                        <p>Then let's add both our tileset (using Map/New Tileset), and the "meta" tileset
                                            that we will use for collision. Both have no spacing or margin, so be sure to let the
                                            corresponding values to zero in tiled (note: melonJS support tilesets with margin and
                                            space)</p><img src="media/step1_newtileset.png" alt="Adding a tileset"/>

                                            <p>For the beauty of it, we will create two layers - one background layer, and one
                                                foreground layer. Feel free to use your imagination and do whatever you want. I named
                                                them logically "background" and "foreground", but you can put whatever you want.</p>

                                                <p>Here's what my level looked like when I finished it : <img src="media/step1_tiled_level_design.png"
                                                  alt="Tiled level design"/></p>

                                                  <p>Finally, let's define a background color for our level, by using the color picker tool (Map/Map Properties), and just specify any
                                                    color you prefer.</p><img src="media/step1_background_color.png" alt=
                                                    "Setting a background color in Tiled"/>

                                                    <p>To finish, let's save our new map as "area01" under the "data" folder. We are done
                                                        the first step!</p>

                                                        <h2><a id="part2">Part 2: Loading our level</a></h2>

                                                        <p>First let's have a look at our js/game.js skeleton :</p>

                            <pre class="brush: js">

                                        /* game namespace */
                                        var game = {

                                            /** 
                                            * an object where to store game global data
                                            */
                                            data : {
                                            // score
                                            score : 0
                                        },
                                        
                                        // Run on page load.
                                        "onload" : function () {

                                            // Initialize the video.
                                            if (!me.video.init("screen", me.video.CANVAS, 640, 480, true, 'auto')) {
                                                alert("Your browser does not support HTML5 canvas.");
                                                return;
                                            }
                                    
                                            // add "#debug" to the URL to enable the debug Panel
                                            if (document.location.hash === "#debug") {
                                                window.onReady(function () {
                                                    me.plugin.register.defer(this, debugPanel, "debug");
                                                });
                                            }       

                                            // Initialize the audio.
                                            me.audio.init("mp3,ogg");

                                            // Set a callback to run when loading is complete.
                                            me.loader.onload = this.loaded.bind(this);
                                            
                                            // Load the resources.
                                            me.loader.preload(game.resources);

                                            // Initialize melonJS and display a loading screen.
                                            me.state.change(me.state.LOADING);
                                        },

                                        // Run on game resources loaded.
                                        "loaded" : function () {
                                            me.state.set(me.state.MENU, new game.TitleScreen());
                                            me.state.set(me.state.PLAY, new game.PlayScreen());

                                            // Start the game.
                                            me.state.change(me.state.PLAY);
                                    }
                                };


                            </pre>

                            <p>This is very simple. Once the page is loaded, the <b>onload()</b> function is
                                called, the display and audio is initialized, and all game resources begin loading.
                                We also define a callback to be called when everything is ready to be used. Within
                                the callback, we define a new state that will be used for the in game stuff, together
                                with a <a href="http://melonjs.github.io/docs/me.ScreenObject.html"> <b>PlayScreen</b> object</a> that we will use to manage the game event (reset,
                                etc...).</p>
                                
                                <p>The only change we will do in the default project template is the given video resolution for the `me.video.init()` function, as for the tutorial we will create a 640x480 canvas. 
                                 You will notice as well later that in the final version of the tutorial, I disabled video scaling by removing the 'auto' parameter, as my intention was to have it fitting my html template.</p>

                                 <p>So in order to load our level, the next thing is to add the resources to be loaded
                                    by adding the following information into <b>game.resources</b> (js/resources.js)
                                    object :</p>

                                    <ul>
                                        <li>the tileset itself, an image</li>

                                        <li>our map "area01", a <a href="https://github.com/bjorn/tiled/wiki/TMX-Map-Format">TMX</a> object</li>
                                    </ul>
                                    <pre class="brush: js">
                                        //game resources
                                        game.resources = [
                                            /**
                                            * Graphics.
                                            */
                                            // our level tileset
                                            {name: "area01_level_tiles",  type:"image", src: "data/img/map/area01_level_tiles.png"},
                                            // our metatiles
                                            {name: "metatiles32x32",  type:"image", src: "data/img/map/metatiles32x32.png"},
                                            
                                            /* 
                                            * Maps. 
                                            */
                                            {name: "area01", type: "tmx", src: "data/map/area01.tmx"}
                                        ];

                                    </pre>

                                    <p>Be sure to name the tileset resource name according to the
                                        filename, or else the level loader will not be able to find the tileset and will fail.</p>

                                        <p>Finally, let's open the js/screens/play.js file and in the <a href="http://melonjs.github.io/docs/me.ScreenObject.html#onResetEvent">onResetEvent()</a> function (which is called on a state
                                            change), we ask the <a href="http://melonjs.github.io/docs/me.levelDirector.html">level director</a> to display our previously preloaded level, by adding a call to the <b>loadLevel</b> function and our default level name :</p>
                                            <pre class="brush: js">
                                            game.PlayScreen = me.ScreenObject.extend({
                                                /** 
                                                *  action to perform on state change
                                                */
                                                onResetEvent: function() {  
                                                
                                                    // load a level
                                                    me.levelDirector.loadLevel("area01");
                                                    
                                                    // reset the score
                                                    game.data.score = 0;
                                                    
                                                    // add our HUD to the game world
                                                    this.HUD = new game.HUD.Container();
                                                    me.game.world.addChild(this.HUD);
                                                
                                                },
                                            
                                                /** 
                                                 *  action to perform when leaving this screen (state change)
                                                 */
                                                onDestroyEvent: function() {
                                                    // remove the HUD from the game world
                                                    me.game.world.removeChild(this.HUD);
                                                }
                                        });

                                </pre>

                                <p><br/>
                                    That's all! If you did everything correctly, and open your index.html (Remember that if you don’t use a web server, you will need to allow your browser to access local files, please refer to the “Testing/debugging” at the beginning of the tutorial if required) :<br/>
                                </p>

                                <h3><a id="part2_try">Try it out</a></h3>

                                <p>(click on the image to see it running in your browser), you should see
                                    something like this </br>
                                    <a href=
                                    "./tutorial_step2/index.html"><img
                                    src="media/tutorial_step2.png" alt=
                                    "Step 2 results"/></a><br/>
                                    Yes, nothing fancy yet, but that's only the beginning!</p>

                                    <p>Also in case you didn't notice, since we defined a 640x480 display in our
                                        application, we only see a part of the map (the half of it to be exact), which is
                                        normal. <b>melonJS</b> automatically creates a corresponding viewport, and we will be
                                        able to navigate through the map in the next step, when we will add a "main
                                        player"</p>

                                        <h2><a id="part3">Part 3: Add a main player</a></h2>

                                        <p>Here we will create a new object by extending the default <a href="http://melonjs.github.io/docs/me.Entity.html"> me.Entity</a>, to create
                                            our player. We will use the provided simple spritesheet <b>(gripe_run_right.png)</b>
                                            to animate our character. It's of course possible to define different animation for
                                            the same entity, but let's keep things simple first.</p><img src=
                                            "media/gripe_run_right.png"
                                            alt="Gripe run right"/>

                                            <p>First, let's add our spritesheet in the list of the resources to be loaded, just
                                                after our map :</p>
                                                <pre class="brush: js">
                                                    //game resources
                                                    game.resources = [{
                                                        /**
                                                        * Graphics.
                                                        */
                                                        // our level tileset
                                                        {name: "area01_level_tiles", type:"image", src: "data/img/map/area01_level_tiles.png"},
                                                        // our metatiles
                                                        {name: "metatiles32x32",  type:"image", src: "data/img/map/metatiles32x32.png"},
                                                        // the main player spritesheet
                                                        {name: "gripe_run_right", type:"image", src: "data/img/sprite/gripe_run_right.png"},
                                                        /* 
                                                        * Maps. 
                                                        */
                                                        {name: "area01", type: "tmx", src: "data/map/area01.tmx"}
                                                    }];
                                            </pre>

                                            <p>Then it's time to create our entity:<br>
                                              (Feel free to put this object either in our main.js or in a new file, in my example I use entities.js)</p>
                                              <pre class="brush: js">
                                            /*------------------- 
                                            a player entity
                                            -------------------------------- */
                                            game.PlayerEntity = me.Entity.extend({

                                                /* -----

                                                constructor

                                                ------ */

                                                init: function(x, y, settings) {
                                                    // call the constructor
                                                    this._super(me.Entity, 'init', [x, y, settings]);

                                                    // set the default horizontal &amp; vertical speed (accel vector)
                                                    this.body.setVelocity(3, 15);

                                                    // set the display to follow our position on both axis
                                                    me.game.viewport.follow(this.pos, me.game.viewport.AXIS.BOTH);
                                                },

                                                /* -----

                                                update the player pos

                                                ------ */
                                                update: function(dt) {

                                                    if (me.input.isKeyPressed('left')) {
                                                        // flip the sprite on horizontal axis
                                                        this.flipX(true);
                                                        // update the entity velocity
                                                        this.body.vel.x -= this.body.accel.x * me.timer.tick;
                                                    } else if (me.input.isKeyPressed('right')) {
                                                        // unflip the sprite
                                                        this.flipX(false);
                                                        // update the entity velocity
                                                        this.body.vel.x += this.body.accel.x * me.timer.tick;
                                                    } else {
                                                     this.body.vel.x = 0;
                                                    }
                                                
                                                    if (me.input.isKeyPressed('jump')) {
                                                        // make sure we are not already jumping or falling
                                                        if (!this.jumping &amp;&amp; !this.falling) {
                                                            // set current vel to the maximum defined value
                                                            // gravity will then do the rest
                                                            this.body.vel.y = -this.body.maxVel.y * me.timer.tick;
                                                            // set the jumping flag
                                                            this.jumping = true;
                                                        }

                                                    }

                                                    // check &amp; update player movement
                                                    this.body.update(dt);

                                                    // update animation if necessary
                                                    if (this.vel.x!=0 || this.vel.y!=0) {
                                                        // update object animation
                                                        this._super(me.Entity, 'update', [dt]);
                                                        return true;
                                                    }
                                                
                                                    // else inform the engine we did not perform
                                                    // any update (e.g. position, animation)
                                                    return false;
                                                }
                                            });
        </pre>

        <p>I think the above code is quite easy to understand. Basically, we extend the
            <a href="http://melonjs.github.io/docs/me.Entity.html"> Entity</a>, configure the default player speed, tweak the camera, 
            test if some keys are pressed and manage our player movement (by setting player speed, and then calling the entity Body <a href="http://melonjs.github.io/docs/me.Body.html#update"> update</a> function). Also, you may notice that I'm
            testing the final velocity (this.body.vel.x and thisbody..vel.y) of my object, which allows me to
            know if my object actually moved, and control if I want the sprite animation to run or not.</p>

            <p>Then, we have to modify our "main" to actually declare our new Object in the object
                <a href="http://melonjs.github.io/docs/me.pool.html"> pool</a> (that is used by the engine to instantiate object), and finally to map the
                keys we will use for the player movement. So our <b>loaded()</b> function will become
                :</p>
                <pre class="brush: js">

                /* ---

                callback when everything is loaded
                
                ---  */
                
                "loaded" : function ()
                {
                    // set the "Play/Ingame" Screen Object
                    me.state.set(me.state.PLAY, new game.PlayScreen());
                    
                    // register our player entity in the object pool
                    me.pool.register("mainPlayer", game.PlayerEntity);
                    
                    // enable the keyboard
                    me.input.bindKey(me.input.KEY.LEFT,  "left");
                    me.input.bindKey(me.input.KEY.RIGHT, "right");
                    me.input.bindKey(me.input.KEY.X,     "jump", true);
                    
                    // start the game 
                    me.state.change(me.state.PLAY);
                }

            </pre>
            <br/>

            <p>And now we can add our entity into the level! Go back to Tiled, add a new Object Layer, and finally a new Entity.
                To create a new Entity use the "Insert Rectangle" Tool to add a rectangle to the object layer, 
                then you can right click the object and add the properties below.</p>

                <p>Name it (case does not matter) <b>mainPlayer</b> (or using the same name you used
                    when registering our Object into the Object Pool), and add two properties to the Object:
                    <ul>
                        <li><b>image</b> : with the <b>gripe_run_right</b> value (name of our resource</li>
                        <li><b>spritewidth</b> : with the value <b>64</b> which is the size of a single sprite in the spritesheet</li>
                        <li><b>spriteheight</b> : we don't define this value here since we use a single line spritesheet,
                            and since in this case the engine will take the actual image height as a value for it.</li>
                        </ul>
                        These two parameters will be passed as parameters (<a href="http://melonjs.github.io/docs/me.ObjectSettings.html"><b>settings</b> object</a> here above
                        used by the constructor) when the object will be created. Now you can either specify
                        these fields here in Tiled, or directly in your code (when dealing with multiple
                        objects, it can be easier to just specify the name in Tiled, and manage the rest in
                        the constructor directly).<br/>
                        <br/>
                        Note: You also free to add as many properties as you want, they will all be available
                        in the settings object passed to your constructor.
                    </p><img src="media/step3_addEntity.png" alt="Adding an entity"/><br><br>


                    <p> Once the object is created just positionate your entity in the level, and as in the below example
                        make sure you are also resizing the object rectangle in Tiled to match with your actual sprite size.
                        <img src="media/step3_object_position.png"alt="positioning an entity"/></p>

                        <h3><a id="define_collision_layer">Define the collision layer</a></h3>

                        <p>We are almost done! The last step is to define the collision layer, for this we
                            will use the other tileset we previously added into Tiled, and specify for each tile
                            a property corresponding to the tile type.</p><img src="media/step3_metatileset.png"
                            alt="Using the meta tileset"/>

                            <p>First, right click on the "Solid" tile (1st one), and add a <b>"type"</b> property
                                with <b>"solid"</b> as a value.</p><img src="media/step3_tile_solid.png" alt=
                                "Configuring the solid tile"/>

                                <p>Then, right click on the "Platform" tile (2nd one), and add a <b>"type"</b>
                                    property with <b>"platform"</b> as a value.</p><img src=
                                    "media/step3_tile_platform.png"
                                    alt="Configuring the platform tile"/>

                                    <p>That's it! Though we won't be using them for this tutorial, it is nice to know
                                        that the others possible values are <b>"lslope"</b> for the left slope,
                                        <b>"rslope"</b> for the right slope, <b>"ladder"</b> for ladder tiles and
                                        <b>"breakable"</b> (you'll never guess) for breakable tiles. Also be careful when
                                        defining these two fields, as the engine is exactly looking for these
                                        labels, so if they are incorrect, it won't work.</p>

                                        <p>Now add a new Tilelayer. This layer <b>MUST contains the keyword "collision"</b>
                                            for the engine to recognize it as a collision layer.</p>

                                            <p>Once the layer added, select it, and just "draw" you level collision map. At the
                                                end it should look like this:</p>
                                                <p><img src="media/step3_collision_draw.png" alt="Drawing the collision layer"/></p>

                                                <h3><a id="part3_try">Try it out</a></h3>

                                                <p>Save everything, and if you now re-open your index.html, you should see something like
                                                    this :<br/>
                                                    (click on the image to see it running in your browser) 
                                                    <a href="./tutorial_step3/index.html"><img src="media/tutorial_step3.png" alt="Step 3 Results"/></a>
                                                    <br/>
                                                </p>

                                                <p>You will also notice that display is automatically following our player.</p>

                                                <p>One last thing - when creating an object, a default collision shape is automatically
                                                    created to manage collision between objects, based on the object size you defined in Tiled.
                                                    For debugging purposes, you can enable the debug panel by adding <b>#debug</b> to URL in the browser URL bar.</p>

                                                    <p>If you reload the game, and enable "hitbox" you will see this:
                                                        <img src="media/step3_debugpanel.png" alt="Enabling the debug panel"/>
                                                    </p>

                                                    <p>The collision box can be adjusted from Tiled by changing the size of the object and match the above example. 
                                                     (Collision Shape can also manually adjusted by accessing the entity body <a href="http://melonjs.github.io/docs/me.Body.html#shapes">shapes</a> property).
                                                 </p>


                                                 <h2><a id="part4">Part 4: Add a scrolling background</a></h2>

                                                 <p>This one is very easy. We don't even have to add a single line of code, since
                                                    everything is done through Tiled.</p>

                                                    <p>First, remove the background color that we added previously at the end of Part 1.
                                                     (to do so, you will need to text edit the TMX file and remove the `backgroundcolor` property).
                                                     Since the background will be filled with our scrolling layers, we don't need the display to be 
                                                     cleared with a specific color (furthermore it will save some precious frames).</p>

                                                     <p>Then we will use the two following backgrounds :</p>

                                                     <p><b>/data/img/area01_bkg0.png</b> for the first background
                                                        layer</p><img src="media/area01_bkg0.png" alt="Parallax background 1"/>

                                                        <p><b>/data/img/area01_bkg1.png</b> for the second background
                                                            layer</p><img src="media/area01_bkg1.png" alt="Parallax background 2"/>

                                                            <p>Let's add them in the resource list:</p>
                                                            <pre class="brush: js">
                                                                // game resources
                                                                game.resources = [
                                                                /**
                                                                * Graphics.
                                                                */
                                                                // our level tileset
                                                                {name: "area01_level_tiles",  type:"image", src: "data/img/map/area01_level_tiles.png"},
                                                                // our metatiles
                                                                {name: "metatiles32x32",  type:"image", src: "data/img/map/metatiles32x32.png"},
                                                                // the main player spritesheet
                                                                {name: "gripe_run_right",     type:"image", src: "data/img/sprite/gripe_run_right.png"},
                                                                // the parallax background
                                                                {name: "area01_bkg0",         type:"image", src: "data/img/area01_bkg0.png"},
                                                                {name: "area01_bkg1",         type:"image", src: "data/img/area01_bkg1.png"},
                                                                
                                                                /* 
                                                                * Maps. 
                                                                */
                                                                {name: "area01",  type: "tmx",  src: "data/map/area01.tmx"}
                                                                ];
                                                            </pre>

                                                            <p>Open Tiled, and add two new <a href="http://melonjs.github.io/docs/me.ImageLayer.html"> <b>Image Layers</b></a>, name them to whatever you like 
                                                                and make sure to adjust correctly the layer order (the display order being from bottom to top)
                                                            </p><img src="media/step4_layer.png" alt="Layering parallax layers"/>

                                                            <p>Now right-click the layers to define their properties and set the following property : <br/>
                                                                - Click the <b>browse</b> button and select the <b>area01_bkg0</b> image for the first layer
                                                                (<b>Parallax_layer1</b> on the picture), and <b>area01_bkg1</b> value for the second
                                                                one (<b>Parallax_layer2</b> also on the picture)<br/></p>

                                                                <p><img src="media/step4_Imagelayer_property.png" alt=
                                                                    "Configuring Image Layer properties"/></p>
                                                                    
                                                                    - And finally add a <a href="http://melonjs.github.io/docs/me.ImageLayer.html#ratio"> <b>ratio</b></a> property to specify the scrolling speed of each layer : we will specify the <b>0.25</b> value for the first layer
                                                                    (<b>Parallax_layer1</b> on the picture) and the <b>0.35</b> value for the second (keep in mind that the smaller the ratio is, the slower the scrolling speed will be).
                                                                    <br/></p>

                                                                    <p>Note that default behavior for Image Layer is to be automatically <a href="http://melonjs.github.io/docs/me.ImageLayer.html#repeat"> <b>repeated</b></a> on both x and y axis, which is exactly what we want here to create the parallax effect.
                                                                    </p>
                                                                    
                                                                    <h3><a id="part4_try">Try it out</a></h3>

                                                                    <p>"Et voila!". If you now open your index.html, you should see:<br/>
                                                                        <a href="./tutorial_step4/index.html"><img src="media/tutorial_step4.png" alt=
                                                                            "Step 4 results"/></a><br/></p>

                                                                            <p>Play around with your player, and enjoy the view :)</p>

                                                                            <h2><a id="part5">Part 5: Adding some basic objects and enemies</a></h2>

                                                                            <p>In this part we will add a collectible coin (that we will use later to add to our
                                                                                score), using the <b>spinning_coin_gold.png</b> spritesheet : <img src=
                                                                                "media/spinning_coin_gold.png"
                                                                                alt="Spinning gold coin"/></p>

                                                                                <p>And a basic enemy, using the <b>wheelie_right.png</b> spritesheet : <img src=
                                                                                    "media/wheelie_right.png"
                                                                                    alt="Wheelie right sprite"/></p>

                                                                                    <p>As always, add them to the resource list:</p>
                                                                                    <pre class="brush: js">
                                                                                        // game resources
                                                                                        game.resources = [
                                                                                        /**
                                                                                        * Graphics.
                                                                                        */
                                                                                        // our level tileset
                                                                                        {name: "area01_level_tiles",  type:"image", src: "data/img/map/area01_level_tiles.png"},
                                                                                        // our metatiles
                                                                                        {name: "metatiles32x32",  type:"image", src: "data/img/map/metatiles32x32.png"},
                                                                                        // the main player spritesheet
                                                                                        {name: "gripe_run_right",     type:"image", src: "data/img/sprite/gripe_run_right.png"},
                                                                                        // the parallax background
                                                                                        {name: "area01_bkg0",         type:"image", src: "data/img/area01_bkg0.png"},
                                                                                        {name: "area01_bkg1",         type:"image", src: "data/img/area01_bkg1.png"},
                                                                                        // the spinning coin spritesheet
                                                                                        {name: "spinning_coin_gold",  type:"image", src: "data/img/sprite/spinning_coin_gold.png"},
                                                                                        // our enemty entity
                                                                                        {name: "wheelie_right",       type:"image", src: "data/img/sprite/wheelie_right.png"},
                                                                                        
                                                                                        /* 
                                                                                        * Maps. 
                                                                                        */
                                                                                        {name: "area01",              type: "tmx",  src: "data/map/area01.tmx"}
                                                                                        ];
                                                                                    </pre>
                                                                                    <br/>

                                                                                    <p>The coin itself is pretty easy; we just extend the <a href="http://melonjs.github.io/docs/me.CollectableEntity.html"> me.CollectableEntity</a>. Actually,
                                                                                        we could directly use it in Tiled (without needing to create CoinEntity here), but
                                                                                        since we will add some score and some audio sfx later when the coin is collected,
                                                                                        let's do it directly this way.</p>

                                                                            <pre class="brush: js">
                                                                                /*----------------
                                                                                  a Coin entity
                                                                                 ----------------- */
                                                                                game.CoinEntity = me.CollectableEntity.extend({
                                                                                    // extending the init function is not mandatory
                                                                                    // unless you need to add some extra initialization
                                                                                    init: function(x, y, settings) {
                                                                                        // call the parent constructor
                                                                                        this._super(me.CollectableEntity, 'init', [x, y , settings]);

                                                                                        // set our collision callback function
                                                                                        this.body.onCollision = this.onCollision.bind(this);
                                                                                    },

                                                                                    // this function is called by the engine, when
                                                                                    // an object is touched by something (here collected)
                                                                                    onCollision: function() {
                                                                                        // do something when collected

                                                                                        // make sure it cannot be collected "again"
                                                                                        this.body.setCollisionMask(me.collision.types.NO_OBJECT);lected "again"

                                                                                        // remove it
                                                                                        me.game.world.removeChild(this);
                                                                                    }
                                                                                });
                                                                            </pre>
                                                                            <p>    
                                                                                Also, just to be sure it's clear for you that both ways of doing this is possible, 
                                                                                we will define the Coin object properties directly in Tiled, so we don't need to add 
                                                                                anything else in the constructor for now :<br>
                                                                                <img src="media/coin_properties.png" alt="Spinning gold coin"/>
                                                                            </p>

                                                                            <br/>

                                                                            <p>For our enemy, it's a bit longer :</p>
                                                                            <pre class="brush: js">
                                        /* --------------------------
                                        an enemy Entity
                                        ------------------------ */
                                        game.EnemyEntity = me.Entity.extend({
                                            init: function(x, y, settings) {
                                                // define this here instead of tiled
                                                settings.image = "wheelie_right";
                                                
                                                // save the area size defined in Tiled
                                                var width = settings.width;
                                                var height = settings.height;

                                                // adjust the size setting information to match the sprite size
                                                // so that the entity object is created with the right size
                                                settings.spritewidth = settings.width = 64;
                                                settings.spritewidth = settings.height = 64;
                                                
                                                // call the parent constructor
                                                this._super(me.Entity, 'init', [x, y , settings]);
                                                
                                                // set start/end position based on the initial area size
                                                x = this.pos.x;
                                                this.startX = x;
                                                this.endX   = x + width - settings.spritewidth
                                                this.pos.x  = x + width - settings.spritewidth;

                                                // walking &amp jumping speed
                                                this.body.setVelocity(4, 6);
                                                
                                            },

                                            // call by the engine when colliding with another object
                                            // obj parameter corresponds to the other object (typically the player) touching this one
                                            onCollision: function(res, obj) {

                                                // res.y &gt;0 means touched by something on the bottom
                                                // which mean at top position for this one
                                                if (this.alive &amp;&amp; (res.y &gt; 0) &amp;&amp; obj.falling) {
                                                    this.renderable.flicker(750);
                                                }
                                            },

                                            // manage the enemy movement
                                            update: function(dt) {
                                                // do nothing if not in viewport
                                                if (!this.inViewport)
                                                return false;

                                                if (this.alive) {
                                                    if (this.walkLeft &amp;&amp; this.pos.x &lt;= this.startX) {
                                                    this.walkLeft = false;
                                                } else if (!this.walkLeft &amp;&amp; this.pos.x &gt;= this.endX) {
                                                    this.walkLeft = true;
                                                }
                                                // make it walk
                                                this.flipX(this.walkLeft);
                                                this.vel.x += (this.walkLeft) ? -this.accel.x * me.timer.tick : this.accel.x * me.timer.tick;
                                                
                                                } else {
                                                    this.vel.x = 0;
                                                }
                                                            
                                                // update the body movement
                                                this.body.update(dt);
                                                
                                                // update animation if necessary
                                                if (this.vel.x!=0 || this.vel.y!=0) {
                                                    // update object animation
                                                    this._super(me.Entity, 'parent', [dt]);
                                                    return true;
                                                }
                                                return false;
                                            }
                                        });
                                        
                                    </pre>

                                    <p>As you can see here, I specified the <b>settings.image</b> and
                                        <b>settings.spritewidth</b> properties in the constructor directly, meaning that in
                                        Tiled, I won't have to add these properties to my Object (Once again, it's up to you
                                        to decide how to use it).<br/>
                                        Also, I am using the <b>width</b> property given by Tiled to specify a path on which
                                        this enemy will run. Finally, in the onCollision method, I make the enemy flicker if
                                        something is jumping on top of it.</p>
                                        
                                        <p>Note that an Object Entity drawable component (either a single sprite of animation) is 
                                            accessible through the Entity `renderable` property, which explains here why we do here the following : `this.renderable.flicker(750);`</p>

                                            <p>Then again, we add these new objects in the Object Pool</p>
                                            <pre class="brush: js">
                                                // register our object entities in the object pool
                                                me.pool.register("mainPlayer", game.PlayerEntity);
                                                me.pool.register("CoinEntity", game.CoinEntity);
                                                me.pool.register("EnemyEntity", game.EnemyEntity);
                                            </pre>
                                            <br/>

                                            <p>And we are ready to complete our level in Tiled. Create a new object layer, and use the Insert Object tool to add coins and enemies where you want. Right-click on each object and make sure to set their name to either CoinEntity or EnemyEntity. <img src=
                                              "media/tutorial_tiled_step5.png" alt="Step 5"/></p>

                                              <p>Before testing, we also need to modify our player to check for collision with other
                                                entities. In order to do this, we add a call to the <a href="http://melonjs.github.io/docs/me.Collision.html#check"> <b>me.collision.check(this)</b></a>
                                                function in our mainPlayer code, see below :</p>
                                                <pre class="brush: js">
    /* -----
       update the player pos
    ------ */
    update: function(dt) {

        if (me.input.isKeyPressed('left'))
        {
            // flip the sprite on horizontal axis
            this.flipX(true);
            // update the entity velocity
            this.vel.x -= this.accel.x * me.timer.tick;
        } 
        else if (me.input.isKeyPressed('right'))
        {
            // unflip the sprite
            this.flipX(false);
            // update the entity velocity
            this.vel.x += this.accel.x * me.timer.tick;
        }
        else
        {
            this.vel.x = 0;
        }
        if (me.input.isKeyPressed('jump'))
        {   
            if (!this.jumping && !this.falling) 
            {
                // set current vel to the maximum defined value
                // gravity will then do the rest
                this.vel.y = -this.maxVel.y * me.timer.tick;
                // set the jumping flag
                this.jumping = true;
            }
        }
        // check & update player movement
        this.body.update(dt);
     
        // check for collision with sthg
        me.collision.check(this, true, this.collideHandler.bind(this), true);
                
        // update animation
        if (this.body.vel.x!=0 || this.body.vel.y!=0)
        {
            // update object animation
            this._super(me.Entity, 'update', [dt]);
            return true;
        }
        
        // else inform the engine we did not perform
        // any update (e.g. position, animation)
        return false;
    },
    
    
    /**
     * colision handler
     */
    collideHandler : function (response) {
        if (response.b.body.collisionType === me.collision.types.ENEMY_OBJECT) {
            if ((response.overlapV.y>0) && !this.body.jumping) {
                // bounce (force jump)
                this.body.falling = false;
                this.body.vel.y = -this.body.maxVel.y * me.timer.tick;
                // set the jumping flag
                this.body.jumping = true;
            }
            else {
                // let's flicker in case we touched an enemy
                this.renderable.flicker(750);
            }
        }
    }

    });
</pre>

<h3><a id="part5_try">Try it out</a></h3>

<p>And this is what you should get (note that I completed the level a little bit, adding
    platforms, etc...) :<br/>
    <a href="./tutorial_step5/index.html"><img src="media/tutorial_step5.png" alt=
        "Step 5 results"/></a><br/></p>

        <p>Try to collect your coins, avoid the enemy or jump on it!</p>

        <h2><a id="part6">Part 6: Adding some basic HUD information</a></h2>

        <p>It's time now to display some score when we collect those coins, right?</p>

        <p>We will use a bitmap font <b>(data/sprite/32x32_font.png)</b> to display our
            score, as always we need to add it in our list of resources to be loaded :</p>
            <pre class="brush: js">
                // game resources
                game.resources = [
                /**
                * Graphics.
                */
                // our level tileset
                {name: "area01_level_tiles",  type:"image", src: "data/img/map/area01_level_tiles.png"},
                // our metatiles
                {name: "metatiles32x32",  type:"image", src: "data/img/map/metatiles32x32.png"},
                // the main player spritesheet
                {name: "gripe_run_right",     type:"image", src: "data/img/sprite/gripe_run_right.png"},
                // the parallax background
                {name: "area01_bkg0",         type:"image", src: "data/img/area01_bkg0.png"},
                {name: "area01_bkg1",         type:"image", src: "data/img/area01_bkg1.png"},
                // the spinning coin spritesheet
                {name: "spinning_coin_gold",  type:"image", src: "data/img/sprite/spinning_coin_gold.png"},
                // our enemty entity
                {name: "wheelie_right",       type:"image", src: "data/img/sprite/wheelie_right.png"},
                // game font
                {name: "32x32_font",          type:"image", src: "data/img/font/32x32_font.png"},

                /*
                * Maps.
                */
                {name: "area01",              type: "tmx",  src: "data/map/area01.tmx"}
                ];
            </pre>
            <br/>

            <p>The boilerplate we used earlier already contains a HUD Skeleton that we will use as a base for our game. The skeleton is
                quite simple and consist of :
                <ul>
                    <li>an object called <b>game.HUD.Container</b>, that inherits from <a href="http://melonjs.github.io/docs/me.Container.html">me.Container</a></li>
                    <li>a basic score object called <b>game.HUD.ScoreItem</b>, that inherits from <a href="http://melonjs.github.io/docs/me.Renderable.html">me.Renderable</a></li>
                </ul>
                The HUD container is just basically an object container, that is defined as <b>persistent</b> (so that it can survive level changes), displayed on top of all others object (z propery set to Infinity),
                and we also make it non collidable so that it just be ignored during collision check.</p>
                <p>
                    The Score Object is defined as <b>floating</b> (so that when we add it to our HUD container we use screen coordinates) and just for now caches the score value (defined under game.data).
                </p>
                <pre class="brush: js">
                    **
                    * a HUD container and child items
                    */

                    game.HUD = game.HUD || {};

                    
                    game.HUD.Container = me.Container.extend({

                        init: function() {
                            // call the constructor
                            this._super(me.Container, 'init');
                            
                            // persistent across level change
                            this.isPersistent = true;
                            
                            // make sure our object is always draw first
                            this.z = Infinity;

                            // give a name
                            this.name = "HUD";
                            
                            // add our child score object at the right-bottom position
                            this.addChild(new game.HUD.ScoreItem(630, 440));
                        }
                    });

                    /** 
                    * a basic HUD item to display score
                    */
                    
                    game.HUD.ScoreItem = me.Renderable.extend( {    
                    
                        /** 
                         * constructor
                         */
                        init: function(x, y) {
                        
                            // call the parent constructor 
                            // (size does not matter here)
                            this._super(me.Renderable, 'init', [x, y, 10, 10]); 

                            
                            // local copy of the global score
                            this.score = -1;

                            // make sure we use screen coordinates
                            this.floating = true;
                        },
                
                        /**
                         * update function
                         */
                        update : function (dt) {
                            // we don't do anything fancy here, so just
                            // return true if the score has been updated
                            if (this.score !== game.data.score) {   
                                this.score = game.data.score;
                                return true;
                            }
                            return false;
                        },

                        /**
                        * draw the score
                        */
                        draw : function (context) {
                            // draw it baby !
                        }

                });
</pre>
<br/>

<p>
    Now let's display our current score ! For that we will just simply complete the given scoreItem object, 
    by creating a local font property (using the previously bitmap font), and simply draw the score using our bitmap font :
</p>
<pre class="brush: js">
    /** 
    * a basic HUD item to display score
    */
    game.HUD.ScoreItem = me.Renderable.extend( {    
        /** 
        * constructor
        */
        init: function(x, y) {
            
            // call the parent constructor 
            // (size does not matter here)
            this.parent(new me.Vector2d(x, y), 10, 10); 
            
            // create a font
            this.font = new me.BitmapFont("32x32_font", 32);
            this.font.set("right");
            
            // local copy of the global score
            this.score = -1;

            // make sure we use screen coordinates
            this.floating = true;
        },

        /**
        * update function
        */
        update : function (dt) {
            // we don't draw anything fancy here, so just
            // return true if the score has been updated
            if (this.score !== game.data.score) {
                this.score = game.data.score;
                return true;
            }
            return false;
        },

        /**
        * draw the score
        */
        draw : function (context) {
            this.font.draw (context, game.data.score, this.pos.x, this.pos.y);
        }
    });
</pre>
<br/>

<p>The HUD is already added and removed when we start the game, so there is nothing to do here : </p>
<pre class="brush: js">
    game.PlayScreen = me.ScreenObject.extend({
        /** 
        *  action to perform on state change
        */
        onResetEvent: function() {  
            
            // load a level
            me.levelDirector.loadLevel("area01");
            
            // reset the score
            game.data.score = 0;
            
            // add our HUD to the game world
            this.HUD = new game.HUD.Container();
            me.game.world.addChild(this.HUD);
            
        },


        /** 
        *  action to perform when leaving this screen (state change)
        */
        onDestroyEvent: function() {
            // remove the HUD from the game world
            me.game.world.removeChild(this.HUD);
        }
    });

</pre>



<p>
    Last step is of course to actually change the score when a coin is collected ! Now let's modify our Coin Object :
</p>
<pre class="brush: js">
    onCollision : function () {
        // do something when collected

        // give some score
        game.data.score += 250;

        // make sure it cannot be collected "again"
        this.body.setCollisionMask(me.collision.types.NO_OBJECT);
        
        // remove it
        me.game.world.removeChild(this);
    }
</pre>

<p>As you can see, in the <b>onCollision function</b>, we just change our game.data.score property by adding some value to it, then we ensure the object cannot be collected again, and remove the coin</p>

<h3><a id="part6_try">Try it out</a></h3>

<p>We can now check the result, and we should now have our score displayed in the
    bottom-right corner of the screen :<br/>
    <a href="./tutorial_step6/index.html"><img src="media/tutorial_step6.png" alt=
        "Step 6 results"/></a><br/></p>

        <h2><a id="part7">Part 7: Adding some audio</a></h2>

        <p>In this section we will add some audio to our game:</p>

        <ul>
            <li>a sound when collecting a coin</li>

            <li>a sound when jumping</li>

            <li>a sound when stomping on enemy</li>

            <li>a background (or in game music)</li>
        </ul>

        <p>Then we will first add them to our resource list:</p>
        <pre class="brush: js">
            //game resources
            game.resources = [
            /**
            * Graphics.
            */
            // our level tileset
            {name: "area01_level_tiles",  type:"image", src: "data/img/map/area01_level_tiles.png"},
            // our metatiles
            {name: "metatiles32x32",  type:"image", src: "data/img/map/metatiles32x32.png"},
            // the main player spritesheet
            {name: "gripe_run_right",     type:"image", src: "data/img/sprite/gripe_run_right.png"},
            // the parallax background
            {name: "area01_bkg0",         type:"image", src: "data/img/area01_bkg0.png"},
            {name: "area01_bkg1",         type:"image", src: "data/img/area01_bkg1.png"},
            // the spinning coin spritesheet
            {name: "spinning_coin_gold",  type:"image", src: "data/img/sprite/spinning_coin_gold.png"},
            // our enemty entity
            {name: "wheelie_right",       type:"image", src: "data/img/sprite/wheelie_right.png"},
            // game font
            {name: "32x32_font",          type:"image", src: "data/img/font/32x32_font.png"},
            
            /* 
            * Maps. 
            */
            {name: "area01",              type: "tmx",  src: "data/map/area01.tmx"},


            /* 
            * Background music. 
            */ 
            {name: "dst-inertexponent", type: "audio", src: "data/bgm/"},
            
            /* 
            * Sound effects. 
            */
            {name: "cling", type: "audio", src: "data/sfx/"},
            {name: "stomp", type: "audio", src: "data/sfx/"},
            {name: "jump",  type: "audio", src: "data/sfx/"}
            ];
        </pre>

        <p>In case you did not notice yet, we didn't specify any extension when adding the
            audio element to the resource list, but instead, the path where the audio can be
            found. Why? Simply because we cannot know which format is supported by the browser.
            Instead, we let melonJS find the right format, and then load the right audio file
            accordingly.</p>

            <p>If we take a look back on how we first initialized the audio, you can see that I
                passed the <b>"mp3,ogg"</b> parameter to the <a href="http://melonjs.github.io/docs/me.audio.html#init">initialization function</a>, asking to try
                to use first the mp3 format, and then ogg as a fallback if mp3 is not supported. This
                also means, in this case, I must provide two versions of my audio files, one as mp3,
                and one as ogg. The engine will then use the right based on your browser
                capabilities</p>
                <pre class="brush: js">
                    // initialize the "audio"
                    me.audio.init("mp3,ogg");
                </pre>

                <p>Still following? Let's modify our game :</p>

                <ul>
                    <li>Collecting a coin</li>
                </ul>

                <p>In the CoinEntity code, where we previously managed our earned points, we just
                    need to add a new call to <a href="http://melonjs.github.io/docs/me.audio.html#play"><b>me.audio.play()</b></a> and use the <b>"cling"</b> audio
                    resource. that's all !</p><br/>
                    <pre class="brush: js">
                        onCollision : function () {
                        // do something when collected

                            // play a "coin collected" sound
                            me.audio.play("cling");

                            // give some score
                            game.data.score += 250;

                            // make sure it cannot be collected "again"
                            this.body.setCollisionMask(me.collision.types.NO_OBJECT);
                            
                            // remove it
                            me.game.world.removeChild(this);
                    }
                </pre>
                <br/>

                <ul>
                    <li>Jumping</li>
                </ul>

                <p>In the <b>update()</b> function of the mainPlayer, we also add a call to
                    <a href="http://melonjs.github.io/docs/me.audio.html#play"><b>me.audio.play()</b></a> and use the <b>"jump"</b> audio resource. You can also note
                    that I added a test on the return value of doJump(). doJump can return false in case
                    you are not allowed to jump (already jumping, etc..) and in that case there is no
                    need to play the sound sfx.</p><br/>
                    <pre class="brush: js">
                    if (me.input.isKeyPressed('jump'))
                    {   
                        if (!this.body.jumping && !this.body.falling) 
                        {
                            // set current vel to the maximum defined value
                            // gravity will then do the rest
                            this.body.vel.y = -this.body.maxVel.y * me.timer.tick;
                            // set the jumping flag
                            this.body.jumping = true;
                            // play some audio 
                            me.audio.play("jump");
                        }
                    }
            </pre>
            <br/>

            <ul>
                <li>Stomping</li>
            </ul>

            <p>And still the same for this one, but using the "stomp" resource, this time in the
                collision handler function of the mainPlayer :</p><br/>
                <pre class="brush: js">
                /**
                 * colision handler
                 */
                collideHandler : function (response) {
                    if (response.b.body.collisionType === me.collision.types.ENEMY_OBJECT) {
                        if ((response.overlapV.y>0) && !this.body.jumping) {
                            // bounce (force jump)
                            this.body.falling = false;
                            this.body.vel.y = -this.body.maxVel.y * me.timer.tick;
                            // set the jumping flag
                            this.body.jumping = true;
                            // play some audio
                            me.audio.play("stomp");
                        }
                        else {
                            // let's flicker in case we touched an enemy
                            this.renderable.flicker(750);
                        }
                    }
                }
</pre>
<br/>

<ul>
    <li>In game music</li>
</ul>

<p>In our main, in the <b>onResetEvent()</b> function, we just add a call to the
    <a href="http://melonjs.github.io/docs/me.audio.html#playTrack"><b>me.audio.playTrack()</b></a> function, specifying the audio track to be used:</p><br/>
    <pre class="brush: js">
    onResetEvent: function() {
        // play the audio track
        me.audio.playTrack("DST-InertExponent");

        ....
    },
</pre>

<p>And we also need to modify the <b>onDestroyEvent()</b> function to stop the
    current track when exiting the game :</p><br/>
    <pre class="brush: js">
    onDestroyEvent: function() {
        
        ....
        
        // stop the current audio track
        me.audio.stopTrack();
    }
</pre>

<p>That's all! click <a href="./tutorial_step7/index.html">here</a> to see the final
    result.</p>

    <h2><a id="part8">Part 8: Adding a second level</a></h2>

    <p>You should know how to create a level now. However, here I will show you how to go
        to another level.</p>

        <p>To do this, melonJS has an Object call <a href="http://melonjs.github.io/docs/me.LevelEntity.html">me.LevelEntity</a>, that we will add in Tiled
            and specify what to do when our main player hit it :</p><img src=
            "media/step8_next_level.png"
            alt="Creating an object to go to next level"/>

            <p>Assuming that our new level is called "area02", we just need to add a <b>"to"</b>
                property with <b>"area02"</b> for the value. So that when our player will hit the
                Object, the engine will automatically load the "area02" level.<br/>
                Optionally we can also ask the engine to add a fadeOut/fadeIn effect when changing
                level by adding the <b>"fade" color</b> and <b>"duration" (in ms)</b> properties (as in the
                image)</p>

                <p>click <a href="./tutorial_step8/index.html">here</a> to see the final result.</p>

                <h2><a id="part9">Part 9: Adding a title screen</a></h2>

                <p>To finish, let's add a title screen to our game, using the <b>title_screen.png</b>
                    files in the <b>"/data/img/gui/"</b> folder (and of course to be added in the ressource list, as we done it previously for other images) : <img src="media/title_screen.jpg" alt=
                    "Title screen"/> and on top of it we will add some message, and wait for the user
                    input to start the game !</p>

                    <p>First let's declare a new Object, extending <a href="http://melonjs.github.io/docs/me.ScreenObject.html">me.ScreenObject</a> :</p>
                    <pre class="brush: js">
                    /**
                    * A title screen 
                    **/
                    game.TitleScreen = me.ScreenObject.extend({
                        // reset function
                        onResetEvent: function() {
                    },

                    // destroy function
                    onDestroyEvent: function() {
                }
            });
        </pre>


        <p>So now we want to:<br/>
            - display the above background image<br/>
            - add some text to the center of the screen ("Press enter to play")<br/>
            - wait for user input (pressing enter)<br/>
            Additionally, I also want to add a small scrolling text about this tutorial.</p>
            <pre class="brush: js">
game.TitleScreen = me.ScreenObject.extend({

    /**    
     *  action to perform on state change
     */
    onResetEvent : function() {
        
        // title screen
        me.game.world.addChild(
            new me.Sprite (
                0,0, 
                me.loader.getImage('title_screen')
            ),
            1
        );
    
        // add a new renderable component with the scrolling text
        me.game.world.addChild(new (me.Renderable.extend ({
            // constructor
            init : function() {
                this._super(me.Renderable, 'init', [0, 0, me.game.viewport.width, me.game.viewport.height]);
                // font for the scrolling text
                this.font = new me.BitmapFont("32x32_font", 32);
                
                 // a tween to animate the arrow
                this.scrollertween = new me.Tween(this).to({scrollerpos: -2200 }, 10000).onComplete(this.scrollover.bind(this)).start();
        
                this.scroller = "A SMALL STEP BY STEP TUTORIAL FOR GAME CREATION WITH MELONJS       ";
                this.scrollerpos = 600;
            },
            
            // some callback for the tween objects
            scrollover : function() {
                // reset to default value
                this.scrollerpos = 640;
                this.scrollertween.to({scrollerpos: -2200 }, 10000).onComplete(this.scrollover.bind(this)).start();
            },
        
            update : function (dt) {
                return true;
            },
            
            draw : function (context) {
                this.font.draw (context, "PRESS ENTER TO PLAY", 20, 240);
                this.font.draw(context, this.scroller, this.scrollerpos, 440);
            },
            onDestroyEvent : function() {
                //just in case
                this.scrollertween.stop();
            }
        })), 2);
        
        // change to play state on press Enter or click/tap
        me.input.bindKey(me.input.KEY.ENTER, "enter", true);
        me.input.bindPointer(me.input.mouse.LEFT, me.input.KEY.ENTER);
        this.handler = me.event.subscribe(me.event.KEYDOWN, function (action, keyCode, edge) {
            if (action === "enter") {
                // play something on tap / enter
                // this will unlock audio on mobile devices
                me.audio.play("cling");
                me.state.change(me.state.PLAY);
            }
        });
    },

    /**    
     *  action to perform when leaving this screen (state change)
     */
    onDestroyEvent : function() {
        me.input.unbindKey(me.input.KEY.ENTER);
        me.input.unbindPointer(me.input.mouse.LEFT);
        me.event.unsubscribe(this.handler);
   }
});
</pre>

<p>What do we have above?<br/>
    1) In the onResetEvent function, we create two renderables components and add them to our game world.
    The first is a basic Sprite object that will display our title background image, and the
    second handles the "press ENTER" message and a scroller based on a Tween object.<br/>
    Note : Concerning the font, if you check carefully the corresponding asset 
    (32x32_font.png), you will notice that it only contains uppercase letters, so be sure 
    as well to only use uppercase letter in your text.<br/>
    2) We also register to key event, or mouse/tap event to automatically switch to the
    PLAY state if pressed.<br/>
    5) On destroy, we unbind the key and pointer events.<br/>
    Easy, no?</p>

    <p>And of course the very last thing is to indicate to the engine we created a new
        object and associate it to the corresponding state (here, <b>MENU</b>). Also, using
        the transition function of <a href="http://melonjs.github.io/docs/me.state.html">me.state</a>, I'm telling the engine to add a fading effect between state
        changes.<br/>
        Finally, instead of switching to the <b>PLAY</b> state at the end of the loaded
        function, I'm switching now to the <b>MENU</b> state:<br/></p>
        <pre class="brush: js">
            /* ---

            callback when everything is loaded

            --- */
            "loaded": function() {
            // set the "Play/Ingame" Screen Object
            me.state.set(me.state.MENU, new game.TitleScreen());

            // set the "Play/Ingame" Screen Object
            me.state.set(me.state.PLAY, new game.PlayScreen());

            // set a global fading transition for the screen
            me.state.transition("fade", "#FFFFFF", 250);

            // register our player entity in the object pool
            me.pool.register("mainPlayer", game.PlayerEntity);
            me.pool.register("CoinEntity", game.CoinEntity);
            me.pool.register("EnemyEntity", game.EnemyEntity);

            // enable the keyboard
            me.input.bindKey(me.input.KEY.LEFT, "left");
            me.input.bindKey(me.input.KEY.RIGHT, "right");
            me.input.bindKey(me.input.KEY.X, "jump", true);

            // display the menu title
            me.state.change(me.state.MENU);
        }

    </pre>

    <h3><a id="part9_try">Try it out</a></h3>

    <p>.... and ... congratulations! You reached the end of this tutorial, time to test
        it, and you should have something like this:</p><a href=
        "./tutorial_step9/index.html"><img
        src="media/tutorial_step9.png" alt=
        "Your completed game"/></a>

        <h2><a id="part10">Part 10: Conclusion</a></h2>

        <p>Well, I hope that you enjoyed this time spent together with this little
            introduction of melonJS. I hope you like it and are willing to give it a try! Please
            keep in mind that melonJS is still in development, so it won't be perfect and that
            it's free! Also, don't hesitate to contact me if you have any feedback, suggestions,
            or found some bugs in the engine (and for sure you'll find some). I will be very
            happy to help you!</p>

            <p>Never forget that this is all for fun, so have fun!</p>
        </div>
    </div>
    <script type="text/javascript">
    SyntaxHighlighter.all()
    </script>


    <div id="content_footer"></div>

    <div id="footer">
        Copyright &copy; melonJS 2011 - 2014
    </div>
</div>
</body>
</html>
